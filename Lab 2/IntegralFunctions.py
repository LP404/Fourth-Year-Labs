#Import neccesary functions
import numpy as np
from inspect import signature
import quantumrandom as qrand
from functools import reduce 
from operator import mul

#Prepares random number generator for lab
#Seed = int(t.time())
Seed = 22061910
SFC64 = np.random.Generator(np.random.SFC64(seed=np.random.SeedSequence(Seed)))

#Sqaures all values in a list
def square(list):
    return [i ** 2 for i in list]

#Note for MC integrator(s) the minimum No of Dims is 1

def MCIntegrator(NoSamples,Integrand,Dims,Lims,DoingNBall):
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass

    
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    

    #Fills list with arrays that correspond to the randomly generated points for the integrator
    for i in range(Dims):
        SampleBox[i] = SFC64.uniform(Lims[i][0],Lims[i][1],NoSamples)
     
    #Checks if the nBall problem is being performed    
    if DoingNBall == True:
        return SampleBox,Lims
    
    else:
    
        #Takes values and 'feeds' them through the function
        Ssum = Integrand(SampleBox)
        
        #If statment checks if the output is a constant value, if so will compute integral seperatley from normal method
        if type(Ssum) == int or type(Ssum) == float:
            return (Lims[0][1] - Lims[0][0]) * Ssum 
        else: 
                                 
            #Output is squared, this is for the uncertantiy
            SsumSq = Ssum**2
            
            #Finds the expectation value for the squared and non sqaured values. The latter is needed for the final answer
            ExpectSsum = sum(Ssum) / NoSamples
            ExpectSsumSq = sum(SsumSq) / NoSamples
            
            #Calcualtes the variance and standard deviation
            Var = ((ExpectSsumSq) - (ExpectSsum)**2)
            Std = (Var)**0.5
            
            #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
            Coef = np.prod(np.diff(Lims))
            
            #Generates final answer
            Final = Coef * ExpectSsum
            
            #Error is generated in accorance with the monte carlo error
            error = Coef * Std / (NoSamples)**0.5
        
    return Lims,SampleBox,Final,error


#Lims,SampleBox,Result,Error,Error2,coef,one = Lancia037(1000000,nDcube,2)

#Takes an input of the samples generated by the monte carlo generator, the generator uses a pass through funcion i.e what comes out is what goes in
def nBallVolume(Samples,Lims,Dims):
    
    #Creates.txt files that will store coordinates of the points generated
    #!!Note!! Disable if running the loop in the main script, this increases runtime massivley
    #out = open('nBall_' + str(Dims) + 'd_InBall.txt' , 'w')
    #out1 = out = open('nBall_' + str(Dims) + 'd_NotBall.txt' , 'w')
        
    #We know that the equation for an n ball is dim1**2 + dim2**2 + ... + dimN**2 = radius**2
    
    #Finds the radius sqaured
    rsq = (np.diff(Lims)[0][0]/2)**2
    
    #Sets the insphere count to 0
    InSphere = 0
    
    #Since all samples are the same length, take Samples[0] to be the number of iterations for the loop
    for i in range(0,len(Samples[0])):
        #Resets total value for each coord point
        total = 0
        for j in range(0,len(Lims)):
            #Finds the sum of all nDimentions**2 by summing the coordinates of the point 
            total += ([row[i] for row in Samples][j] - np.mean(Lims[0]))**2
        
        #Checks if the point is in the nBall or not
        #If so, updates the count by 1 if not discards point
        if total <= rsq:
            InSphere += 1
            #Appends coordinate to .txt file
            #out.write(f"{[row[i] for row in Samples]}")
        else:
            #Appends coordinate to .txt file
            #out1.write(f"{[row[i] for row in Samples]}")
            pass
    
    #Finds volume of nBall
    Volume = np.prod(np.diff(Lims)) * (InSphere / len(Samples[0]))
    
    #Closes .txt file
    #out.close()
    #out1.close()
    #Returns the InSphere count and the volume
    return InSphere ,Volume


#Metropolis algorithym
def metropolis(x0, delta, n, Integrand):
    x = np.zeros(n)
    x[0] = x0
    i = 1
    
    while x[-1] == 0:
        #Get the current xValue
        xCurrent = x[i-1]
        #Generate trial value
        xTemp = xCurrent + SFC64.uniform(-delta,delta)
        #Calculate acceptance ratio
        w = Integrand(xTemp) / Integrand(xCurrent)
        #Checks if the acceptance ratio is below one
        if w <= 1:
            #Sets x to the trial value
            xCurrent = xTemp
            #Adds current value to the array
            x[i-1] = xCurrent
            #Increases the counter by one
            i+=1
        else:
            #Generates a value for r and compares to w 
            r = SFC64.uniform(0,1)
            if r <= w:
                #Sets x to the trial value
                xCurrent = xTemp
                #Adds current value to the array
                x[i-1] = xCurrent
                #Increases the counter by one
                i+=1  
            else:
                pass
    #Burns 10% of the values and only takes every second remaining value
    return x[int(n/10)::2]

#Monte Carlo Integrator with importance sampeling
def MCISIntegrator(delta,initGuess,n,Integrand,WeightFunc,Dims,Lims,DoingNBall):
    
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass
        
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    
    
    #Generates samples via the metropolis algorithim
    #Puts them in the same sample box list
    for i in range(Dims):
        SampleBox[i] = metropolis(initGuess[i], delta, n, WeightFunc)
     
    #Checks if the nBall problem is being performed    
    if DoingNBall == True:
        return Lims,SampleBox
    
    else:
    
        #Generates the output of the function(s) for the importance sampling method
        Ssum = (Integrand(SampleBox) / WeightFunc(SampleBox))
    

        #Generates the normalisation coeffiecnet, exists as an array now but will be summed
        Norm = 1 / WeightFunc(SampleBox)
    
        #If statment checks if the output is a constant value, if so will compute integral seperatley from normal method
        if type(Ssum) == int or type(Ssum) == float:
            return (Lims[0][1] - Lims[0][0]) * Ssum / Norm
        else: 
        
        
                
            #Finds the values squared for the variance
            SsumSq = Ssum**2
            
            
            #Calcaultes the expectation values for finding the total and the squared values for the variance
            ExpectSsum = sum(Ssum) / sum(Norm)
            ExpectSsumSq = sum(SsumSq) / sum(Norm)
            
            #Find the variance
            Var = ((ExpectSsumSq) - (ExpectSsum)**2)
            
            #Find the standard deviation
            Std = (Var)**0.5
            
            #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
            Coef = np.prod(np.diff(Lims))
            
            #Generates final answer
            Final = Coef * ExpectSsum
            
            #Error is generated in accorance with the monte carlo importance sampling error
            error = Coef * Std / n**0.5
    
    return Lims,SampleBox,Final, error

#A small function that will run if you directly run this script (not imported into another script), purely asthetic
def main():
    print('Oh, you\'re actually running this file directly?\nHave a cookie -> üç™ ')
    return

#Will run main function of the script is run directly
if __name__ == '__main__':
    main()