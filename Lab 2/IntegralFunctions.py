#Import neccesary functions
import numpy as np
from inspect import signature
import time as t

#Prepares random number generator for lab
#Seed = int(t.time())
Seed = 22061910
SFC64 = np.random.Generator(np.random.SFC64(seed=np.random.SeedSequence(Seed)))

#Sqaures all values in a list
def square(list):
    return [i ** 2 for i in list]

#Note for MC integrator(s) the minimum No of Dims is 1

def MCIntegrator(NoSamples,Integrand,Dims,Lims,DoingNBall):
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass

    
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    

    #Fills list with arrays that correspond to the randomly generated points for the integrator
    for i in range(Dims):
        SampleBox[i] = SFC64.uniform(Lims[i][0],Lims[i][1],NoSamples)
     
    #Checks if the nBall problem is being performed    
    if DoingNBall == True:
        return Lims,SampleBox
    
    else:
    
        #Takes values and 'feeds' them through the function
        Ssum = Integrand(SampleBox)
        
        #If statment checks if the output is a constant value, if so will compute integral seperatley from normal method
        if type(Ssum) == int or type(Ssum) == float:
            return (Lims[0][1] - Lims[0][0]) * Ssum 
        else: 
                                 
            #Output is squared, this is for the uncertantiy
            SsumSq = Ssum**2
            
            #Finds the expectation value for the squared and non sqaured values. The latter is needed for the final answer
            ExpectSsum = sum(Ssum) / NoSamples
            ExpectSsumSq = sum(SsumSq) / NoSamples
            
            #Calcualtes the variance and standard deviation
            Var = ((ExpectSsumSq) - (ExpectSsum)**2)
            Std = (Var)**0.5
            
            #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
            Coef = np.prod(np.diff(Lims))
            
            #Generates final answer
            Final = Coef * ExpectSsum
            
            #Error is generated in accorance with the monte carlo error
            error = Coef * Std / (NoSamples)**0.5
        
    return Lims,SampleBox,Final,error



#Takes an input of the samples generated by the monte carlo generator, the generator uses a pass through funcion i.e what comes out is what goes in
def nBallVolume(Samples,Lims,Dims,NoSamples):
    
    # Creates.txt files that will store coordinates of the points generated
    #Txts are generated procedurally based on the input data
    # !!Note!! Disable if running the loop in the main script, this increases runtime massivley
    DimCounter = np.arange(1,Dims+1,1)
    for i in range(0,Dims):
        vars()['Out_dimention_'+str(DimCounter[i])] = open(str(NoSamples)+'_samples_nBall_No'+str(DimCounter[i])+'_Axis_' + str(Dims) + 'd_InBall.txt' , 'w')
        vars()['Out1_dimention_'+str(DimCounter[i])] = open(str(NoSamples)+'_samples_nBall_No'+str(DimCounter[i])+'_Axis_' + str(Dims) + 'd_NotInBall.txt' , 'w')
        
    #We know that the equation for an n ball is dim1**2 + dim2**2 + ... + dimN**2 = radius**2
    
    #Finds the radius sqaured
    rsq = (np.diff(Lims)[0][0]/2)**2
    
    #Sets the insphere count to 0
    InSphere = 0
    
    #Since all samples are the same length, take Samples[0] to be the number of iterations for the loop
    for i in range(0,len(Samples[0])):
        #Resets total value for each coord point
        total = 0
        for j in range(0,len(Lims)):
            #Finds the sum of all nDimentions**2 by summing the coordinates of the point 
            total += ([row[i] for row in Samples][j] - np.mean(Lims[0]))**2
        
        
        #Will append to each txt for each axis for each sphere
        for l in range(0,len(DimCounter)):
            #Checks for if it the last append, if so  will not add a semicolon at the end. Semicolon is needed as a delimiter
            if i == (len(Samples[0]) - 1):        
                #Checks if the point is in the nBall or not
                #If so, updates the count by 1 if not discards point
                if total <= rsq:
                    InSphere += 1
                    # Appends coordinate to .txt files
                    vars()['Out_dimention_'+str(DimCounter[l])].write(f"{Samples[l][i]}")
                else:
                    # Appends coordinate to .txt files
                    vars()['Out1_dimention_'+str(DimCounter[l])].write(f"{Samples[l][i]}")
            else:
                #Checks if the point is in the nBall or not
                #If so, updates the count by 1 if not discards point
                if total <= rsq:
                    InSphere += 1
                    # Appends coordinate to .txt files
                    vars()['Out_dimention_'+str(DimCounter[l])].write(f"{Samples[l][i]};")
                else:
                    # Appends coordinate to .txt files
                    vars()['Out1_dimention_'+str(DimCounter[l])].write(f"{Samples[l][i]};")

    
    #Finds volume of nBall
    Volume = np.prod(np.diff(Lims)) * (InSphere / len(Samples[0]))
    
    # Closes .txt files
    for i in range(0,Dims):
        vars()['Out_dimention_'+str(DimCounter[i])].close()
        vars()['Out1_dimention_'+str(DimCounter[i])].close()
    # Returns the InSphere count and the volume
    return InSphere ,Volume


#Metropolis algorithym
def metropolis(x0, delta, n, Integrand):
        
    #Initilises the Metropolis algorithim
    x = np.zeros(n)
    x[0] = x0
    
    #Initilise loop
    for i in range(1,len(x)):
        
        #Gets current x value from x array
        xCurrent = x[i-1]
        
        #Generates trial value
        xTrial = xCurrent + SFC64.uniform(-delta,delta)
        
        #Finds weght
        w = Integrand(xTrial) / Integrand(xCurrent)

        #Check is weight exceeds 1, if so sets new x value to weight        
        if w >= 1:
            x[i] = xTrial 
        
        else:
            #Generates r value
            r = SFC64.uniform(0,1)
            #If r value is less than weight, adopts trial value for new x value
            if r <= w:
                x[i] = xTrial 
                
            #If both previous conditions are new, adopts current x value for new x value
            else:
                x[i] = xCurrent
            
    #Burns 10% of the values and only takes every second remaining value
    out = x[int(n/10)::2]
    return out

 
    
#Monte Carlo Integrator with importance sampeling
def MCISIntegrator(delta,initGuess,n,Integrand,WeightFunc,Dims,Lims,DoingNBall):
    
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass
        
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    
    
    #Generates samples via the metropolis algorithim
    #Puts them in the same sample box list
    for i in range(Dims):
        SampleBox[i] = metropolis(initGuess[i], delta, n, WeightFunc)
     
    #Checks if the nBall problem is being performed    
    if DoingNBall == True:
        return Lims,SampleBox
    
    else:
    
        #Generates the output of the function(s) for the importance sampling method
        Ssum = (Integrand(SampleBox) / WeightFunc(SampleBox))
    

        #Generates the normalisation coeffiecnet, exists as an array now but will be summed
        Norm = (1 / WeightFunc(SampleBox))
    
        #If statment checks if the output is a constant value, if so will compute integral seperatley from normal method
        if type(Ssum) == int or type(Ssum) == float:
            return (Lims[0][1] - Lims[0][0]) * Ssum / Norm
        else: 
        
        
                
            #Finds the values squared for the variance
            SsumSq = Ssum**2
            NormSq = Norm**2
            
            
            #Calcaultes the expectation values for finding the total and the squared values for the variance
            ExpectVal = sum(Ssum) / sum(Norm) 
            ExpectValSq = sum(SsumSq) / sum(NormSq)
            
            
            #Find the variance of the importance sampled values
            Var = ((ExpectValSq) - (ExpectVal)**2) / len(SampleBox[0])
            
            #Find the standard deviation
            Std = (Var)**0.5
            
            #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
            Coef = np.prod(np.diff(Lims))
            
            # Generates final answer
            Final = Coef * ExpectVal
            
            #Error is generated in accorance with the monte carlo importance sampling error
            error = Coef * Std / len(SampleBox[0])**0.5
            
        
    return Lims,SampleBox,Final, error


#A small function that will run if you directly run this script (not imported into another script), purely asthetic
def main():
    print('Oh, you\'re actually running this file directly?\nHave a cookie -> üç™ ')
    return

#Will run main function of the script is run directly
if __name__ == '__main__':
    main()