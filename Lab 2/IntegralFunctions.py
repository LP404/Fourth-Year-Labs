#Import neccesary functions
import numpy as np
from inspect import signature
import quantumrandom as qrand
from functools import reduce 
from operator import mul

#Prepares random number generator for lab
#Seed = int(t.time())
Seed = 22061910
SFC64 = np.random.Generator(np.random.SFC64(seed=np.random.SeedSequence(Seed)))

#Reshapes a list
def reshape(ListIn, shape):
    #Returns list if its already flattened
    if len(shape) == 1:
        return ListIn
    #Flattens list
    n = reduce(mul, shape[1:])
    #Reshapes list to desired shape
    return [reshape(ListIn[i*n:(i+1)*n], shape[1:]) for i in range(len(ListIn)//n)]

#Note for MC integrator(s) the minimum No of Dims is 1

def MCIntegrator(NoSamples,Integrand,Dims):
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass
    
    #Creates a list to hold arrays for each dimention#s limits
    Lims = [[] for _ in range(0,Dims)]
    
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    
    #Gathers a lower and upper limit for each dimention
    for i in range(Dims):
        while True:   
            try:
                #input() must be converted to a float as input() returns a str()
                lower = float(input('Value of lower limit for dimention '+str(i+1)+' : '))
                upper = float(input('Value of upper limit for dimention '+str(i+1)+' : '))
                print('\n')
                break
            except ValueError:
                #Sanity check that will discard non numbers
                print("Value is not a real number, try again")
        #Inserts values into the limits
        Lims[i].insert(0,lower)
        Lims[i].insert(1,upper)
    
    
    #Fills list with arrays that correspond to the randomly generated points for the integrator
    for i in range(Dims):
        SampleBox[i] = SFC64.uniform(Lims[i][0],Lims[i][1],NoSamples)
        
    
    #Takes values and 'feeds' them through the function
    Ssum = Integrand(SampleBox)
    
    #Output is squared, this is for the uncertantiy
    SsumSq = Ssum**2
    
    #Finds the expectation value for the squared and non sqaured values. The latter is needed for the final answer
    ExpectSsum = sum(Ssum) / NoSamples
    ExpectSsumSq = sum(SsumSq) / NoSamples
    
    #Calcualtes the variance and standard deviation
    Var = ((ExpectSsumSq) - (ExpectSsum)**2)
    Std = (Var)**0.5
    
    #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
    Coef = np.prod(np.diff(Lims))
    
    #Generates final answer
    Final = Coef * ExpectSsum
    
    #Error is generated in accorance with the monte carlo error
    error = Coef * Std / (NoSamples)**0.5
    
    return Lims,SampleBox,Final, error


#Lims,SampleBox,Result,Error,Error2,coef,one = Lancia037(1000000,nDcube,2)

#Takes an input of the samples generated by the monte carlo generator, the generator uses a pass through funcion i.e what comes out is what goes in
def nBallVolume(Samples,Lims):
    #Checks if the limits pretaine to a n ball, by checking if they are all the same length in each axis and occupy the same respective coorsinates in each axis
    check = True
    for i in range(1,len(Lims)):
        if Lims[i] == Lims[i-1]:
            pass
        else:
            check = False
    if check == False:
        print('nBall calcualtion is not possible, check limits')
        return
    else:
        pass
    
    #We know that the equation for an n ball is dim1**2 + dim2**2 + ... + dimN**2 = radius**2
    
    #Finds the radius sqaured
    rsq = (np.diff(Lims)[0][0]/2)**2
    
    #Sets the insphere count to 0
    InSphere = 0
    
    #Since all samples are the same length, take Samples[0] to be the number of iterations for the loop
    for i in range(0,len(Samples[0])):
        #Resets total value for each coord point
        total = 0
        for j in range(0,len(Lims)):
            #Finds the sum of all nDimentions**2 by summing the coordinates of the point 
            total += ([row[i] for row in Samples][j] - np.mean(Lims[0]))**2
        
        #Checks if the point is in the nBall or not
        #If so, updates the count by 1 if not discards point
        if total <= rsq:
            InSphere += 1
        else:
            pass
    
    #Finds volume of nBall
    Volume = np.prod(np.diff(Lims)) * (InSphere / len(Samples[0]))
    
    #Returns the InSphere count and the volume
    return InSphere ,Volume


#Metropolis algorithym
def metropolis(x0, delta, n, Integrand):
    x = np.zeros(n)
    x[0] = x0
    i = 1
    
    while x[-1] == 0:
        #Get the current xValue
        xCurrent = x[i-1]
        #Generate trial value
        xTemp = xCurrent + SFC64.uniform(-delta,delta)
        #Calculate acceptance ratio
        w = Integrand(xTemp) / Integrand(xCurrent)
        #Checks if the acceptance ratio is below one
        if w <= 1:
            #Sets x to the trial value
            xCurrent = xTemp
            #Adds current value to the array
            x[i-1] = xCurrent
            #Increases the counter by one
            i+=1
        else:
            #Generates a value for r and compares to w 
            r = SFC64.uniform(0,1)
            if r <= w:
                #Sets x to the trial value
                xCurrent = xTemp
                #Adds current value to the array
                x[i-1] = xCurrent
                #Increases the counter by one
                i+=1  
            else:
                pass
    #Burns half of the values and only takes every second value
    return x[int(n/10)::2]

#Monte Carlo Integrator with importance sampeling
def MCISIntegrator(delta,n,Integrand,WeightFunc,Dims):
    
    #Will check if there are any unspecified dimentions
    #If there are any the function will abort and send an error message
    DimsCheck = len(signature(Integrand).parameters)
    if DimsCheck > Dims:
        print('There are dimentions that have no limits assigned to them')
        #return
    else:
        pass
    
    #Creates a list to hold arrays for each dimention#s limits
    Lims = [[] for _ in range(0,Dims)]
    
    #Creates a list to hold all randomly generated points for the integrator
    SampleBox = [[] for _ in range(0,Dims)]
    
    #Creates an array to store the inital guess values
    #Note: I don't like having nested arrays, it's just a personal thing
    initGuess = np.zeros(Dims)
    
    
    #Gathers a lower and upper limit for each dimention and an inital guess value
    for i in range(Dims):
        while True:   
            try:
                #Like before the string must be converted into a float
                lower = float(input('Value of lower limit for dimention '+str(i+1)+' : '))
                upper = float(input('Value of upper limit for dimention '+str(i+1)+' : '))
                initGuess[i] = float(input('Inital guess value for dimention '+str(i+1)+' : '))
                print('\n')
                break
            except ValueError:
                #Uses the same method to reject any non valid inputs
                print("Value is not a real number, try again")
        #Inserts values into the limits
        Lims[i].insert(0,lower)
        Lims[i].insert(1,upper)
    
    #Generates samples via the metropolis algorithim
    #Puts them in the same sample box list
    for i in range(Dims):
        SampleBox[i] = metropolis(initGuess[i], delta, n, Integrand)
        
    
    #Generates the normalisation coeffiecnet, exists as an array now but will be summed
    Norm = 1 / WeightFunc(SampleBox)
    
    #Generates the output of the function(s) for the importance sampling method
    Ssum = (Integrand(SampleBox) / WeightFunc(SampleBox))
    
    #Finds the values squared for the variance
    SsumSq = Ssum**2
    
    #Calcaultes the expectation values for finding the total and the squared values for the variance
    ExpectSsum = sum(Ssum) / sum(Norm)
    ExpectSsumSq = sum(SsumSq) / sum(Norm)
    
    #Find the variance
    Var = ((ExpectSsumSq) - (ExpectSsum)**2)
    
    #Find the standard deviation
    Std = (Var)**0.5
    
    #Calcualtes the difference between the limits for the coefficent that will be multipled by the expectation value
    Coef = np.prod(np.diff(Lims))
    
    #Generates final answer
    Final = Coef * ExpectSsum
    
    #Error is generated in accorance with the monte carlo importance sampling error
    error = Coef * Std / n
    
    return Lims,Final, error

#A small function that will run if you directly run this script (not imported into another script), purely asthetic
def main():
    print('Oh, you\'re actually running this file directly?\nHave a cookie -> üç™ ')
    return

#Will run main function of the script is run directly
if __name__ == '__main__':
    main()